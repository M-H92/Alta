<!DOCTYPE html><html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preload" as="fetch" crossorigin="anonymous" href="/_payload.json?6dfd114d-e386-4ca1-81b4-a7bcd2d9e858">
<style>.lateral-navbar{align-items:stretch;background-color:#fff;border-radius:0 5px 5px 0;box-shadow:9px 2px 9px -4px rgba(0,0,0,.5);display:flex;flex-direction:column;height:100vh;left:-180px;padding:25px 0;position:fixed;top:0;transition:.5s ease-in-out;width:200px}.lateral-navbar:hover{left:0;transition:.5s ease-in-out}.lateral-navbar>button{background-color:unset;border:none;cursor:pointer;font-size:24px;padding-bottom:8px;padding-top:8px}.lateral-navbar>button:hover{background-color:rgba(0,0,0,.1)}main{padding-top:2vh}h1{font-size:3em}section{margin-left:auto;margin-right:auto;max-width:50vw}</style>
<style>*,:after,:before{box-sizing:border-box}*{margin:0}body{line-height:1.5;-webkit-font-smoothing:antialiased}canvas,img,picture,svg,video{display:block;max-width:100%}button,input,select,textarea{font:inherit}h1,h2,h3,h4,h5,h6,p{overflow-wrap:break-word}#__next,#root{isolation:isolate}*{color:unset}</style>
<style>#the-nav-bar{background-color:#000;color:#fff}</style>
<link rel="stylesheet" href="/_nuxt/entry.DkBHNvwp.css">
<link rel="modulepreload" as="script" crossorigin href="/_nuxt/DRj5MFIH.js">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/DH9nclK4.js">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/lWbOvXNG.js">
<link rel="prefetch" as="script" crossorigin href="/_nuxt/DKo2UBUw.js">
<script type="module" src="/_nuxt/DRj5MFIH.js" crossorigin></script></head><body><div id="__nuxt"><div><!--[--><nav class="lateral-navbar"><hr><!--[--><!--[--><button>Préambule</button><hr><!--]--><!--[--><button>Première DB</button><hr><!--]--><!--[--><button>Relations</button><hr><!--]--><!--[--><button>Contraintes</button><hr><!--]--><!--[--><button>Index</button><hr><!--]--><!--]--><button>Tout</button></nav><main><section><h1>Préambule</h1><ol><li>Introduction</li><li>Pourquoi une base de données</li><li>Terminologies de base</li><li>Installation</li><li>Conclusion</li></ol><hr><h2>Introduction</h2><p> Dans cette section, nous allons voir le but de l&#39;ajout d&#39;une <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> à votre projet de développement ainsi que quelques mots de vocabulaire de base. <br> Nous téléchargerons aussi les programmes nécessaire pour la suite de ce cours </p><h2>Pourquoi une base de données</h2><p> En tant que développeur, vous allez créer des systèmes remplissant trois rôles qui sont, au sens large </p><ol><li>Intégrer des donnée</li><li>Manipuler des donnée</li><li>Restituer des donnée</li></ol><p>Quelques exemples en vrac :</p><p>Intégrer des données :</p><ul><li> Lors d&#39;une inscription à un service web, récupération des informations d&#39;un formulaire en ligne </li><li> Lors de la génération d&#39;une facture depuis un devis, lecture des fichiers de devis </li><li>Dans un jeu vidéo, quelle touche est pressée</li></ul><p>Manipuler des données</p><ul><li> Validations des données d&#39;un formulaire d&#39;inscription (âge ok? complexité du mdp ok?) </li><li>Calcul des montants d&#39;une facture sur base du devis</li><li> Quelle action doit réaliser le personnage, est-ce que son étât le lui permet? Quel résultat dans le monde </li></ul><p>Restituer des données</p><ul><li> Feedback utilisateur d&#39;inscription réussie, affichage de ses données dans une page &quot;profil&quot;... </li><li>Envoi de la facture vers une imprimante</li><li> Affichage de la prochaine frame à l&#39;écran correctement mise à jour </li></ul><p> Dans cette <strong>optique de gestion des données</strong>, une <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> pourra être mise en place pour faire <strong>persister</strong> les données et les <strong>restituer</strong> plus tard... </p><p> Tout comme il serait possible de le faire avec un fichier ou même un classeur et du papier... </p><p> Il sera par conséquent important lors du processus d&#39;analyse d&#39;évaluer l&#39;intérêt de la mise en place d&#39;une <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> en prenant en considération les avantages qu&#39;elle apporte </p><ul><li>Récupération efficace et modulable de la donnée</li><li>Gestion de la concurence lors du travail à plusieurs</li><li>Sécurité sur l&#39;accès en lecture et en écriture</li><li>Accessibilité</li><li>Manipulation de la donnée</li><li>Périnité</li><li>Récupération et systèmes de backup</li><li>...</li></ul><p> Dans les cas précédents, il serait raisonnable d&#39;imaginer l&#39;utilisation d&#39;une <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> pour gérer les utilisateurs de son service ou les factures de son entreprise. </p><p> il serait par contre difficilement justifiable d&#39;en utiliser une pour sauvegarder les inputs d&#39;un jeu vidéo qui sont des données à caractère plus volatil et destinées à être utilisées sur le moment. </p><p> On peut imaginer d&#39;autres cas d&#39;utilisation comme une entreprise souhaitant accéder à ses résultats comptables sur plusieurs années pour en extrapoler des prévisions pour les années à venir, un institut météorologique récupérant quotidiennement les données météo pour aggréger des moyennes et autres statistiques, un établissement scolaire souhaitant garder une trace des résultats des étudiants pendant plusieurs années... </p><h2>Installation</h2><p> Pour ce cours, nous allons utiliser système de gestion de base de données <strong>postgreSQL</strong> ainsi que le logiciel <strong>pgAdmin</strong></p><p> Vous pouvez télécharger l&#39;installeur pour ces deux éléments sur <a href="https://www.postgresql.org/download/">le site officiel</a> de postgreSQL. <br> Ce cours utilise la version 16.4 de postgre, mais rien ne vous empêche de prendre une version plus à jour. <br> Si à ce stade, vous n&#39;êtes pas certain de pouvoir bien cerner les différences entre PostgreSQL, pgAdmin et SQL, je vous sugggère de lire la prochaine section pendant votre téléchargement. </p><p> Lorsque votre téléchargement est terminé, vous devriez pouvoir lancer l&#39;installeur et conserver les options par défaut. <br> Notez qu&#39;il ne sera pas nécessaire pour ce cours de faire des installations supplémentaires via Stack builder </p><p> Une fois installé, vérifiez que tout se soit bien passé en ouvrant le programme pgAdmin et en vous connectant au server grâce au mot de passe attribué pendant l&#39;installation </p><h2>Terminologies de base</h2><p><strong>Base de données relationnelle</strong>. Il s&#39;agit d&#39;un type de base de données impliquant des <strong>relations</strong> entre les différentes entités. </p><p><strong>Système de Gestion de Base de Données </strong>. Il s&#39;agit du système permettant de gérer des base de données. MySQL, SQLServer, MariaDB ou PostGreSQL sont des systèmes de gestion de bases de données relationnelle </p><p><strong>SQL</strong> ou <span title="Langage de requête structuré"> Structured Query Language </span> est le <strong>langage</strong> permettant de communiquer avec les bases de données. </p><p> Logiciel de <strong>gestion et d&#39;administration</strong> de base de données. Il s&#39;agit de programmes permettant de manipuler les bases de données. MySQL Workbench, SQL Server Management Studio ou pgAdmin en sont des exemples </p><p> Bien que ces éléments soient en essence bien distincts, une confusion apparait parfois au vu de la proximité des termes utilisés. Il est bien important de comprendre que... </p><p> SQL est le <strong>langage</strong> qui sera utilisé... Aussi bien sur MySQL que sur SQL Server, postgreSQL,... (avec parfois de légères variations) </p><p> Pour manipuler une base de données, un système de gestion de base de données sera nécessaire. <br> Le choix entre les différents concurent se fera selon les critères de prix, de compatilibité avec son projet de développement, d&#39;efficacité, de philosophie (certains sont open source) </p><p> La plupart des système de gestion de base de données disposent d&#39;un logiciel permettant de manipuler les bases de données. <br> Bien que ces logiciels ne soient pas obligatoires, ils simplifient fortement l&#39;utilisation d&#39;une base de données. <br> Comme pour les systèmes de gestion de base de données, de multiples concurents existent et, bien souvent, les logiciels vont de paire avec un système particulier. <br> On aura par exemple MySQL avec MySQL Workbench par Oracle, SQL Server et SQL Server Management Studio par Microsoft, PostGreSQL et pgAdmin,... </p><h2>Conclusion</h2><p> Au terme de cette section d&#39;introduction, vous devriez maintenant avoir une idée de l&#39;intérêt que peut avoir une <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> ainsi que de disposer de tout les outils nécessaires pour commencer à les manipuler. <br> Rendez-vous à la prochaine section pour ce faire </p></section><hr><section><h1> Première <abbr class="db-tooltip tooltip" title="DataBase =&gt; Base de données">DB</abbr></h1><ol><li>Introduction</li><li>Créer une base de donnée</li><li>Créer une table</li><li>Ajouter des enregistrements</li><li>Lire les enregistrements</li><li>Conclusion</li></ol><hr><h2>Introduction</h2><p> Dans cette section, nous allons créer notre première <abbr class="db-tooltip tooltip" title="DataBase =&gt; Base de données"> DB </abbr> &quot;fat_cat_clinic&quot; ayant pour but d&#39;enregistrer le poids de votre animal de compagnie favoris <br> Nous verrons comment enregistrer et récupérer des données dans celle-ci et nous manipuleron pgAdmin pour la première fois <br> Notez bien que cette section ne fera qu&#39;introduire les différents concepts de création, lecture, écriture... <br> Ceux-ci seront détaillés plus avant dans les prochaines sections </p><h2>Créer une base de données</h2><p> Lancez le programme pgAdmin et connectez vous. <br> À gauche se siture <strong>l&#39;object explorer</strong> avec lequel vous pourrez facilement naviguer entre vos bases de données. <br> Naviguez dans celui-ci en ouvrant l&#39;élément <strong>database</strong>. <br> Là, vous devriez voir une première base de données nommée <strong>postgre</strong> <br> À l&#39;aide d&#39;un clique droit sur cette dernière, ouvrez le menu contextuel et sélectionnez l&#39;option <strong>Query Tool</strong> <br> Le query tool vous permet d&#39;écrire vos <strong title="requêtes" class="tooltip">queries</strong><strong>SQL</strong> et ainsi de communiquer avec votre système de gestion de base de données. </p><p> Dans le query tool, entrez la ligne de code suivante pour créer votre première base de données </p><code lang="sql">CREATE DATABASE fat_cat_clinic;</code><p> Pour ceux qui parlent un peu anglais, vous comprendrez rapidement ce dont il est question ici. <br> Nous <i>créons</i> une <i>base de données</i> dont le nom est fat_cat_clinic. Le <kbd>;</kbd> signifiant la fin de la requête sql <br> Avant d&#39;exécuter ce code, remarquez aussi que certains mots sont colorés. <br> Il s&#39;agit de mots clés spécifique au langage <strong>SQL</strong> et sont dit <i>réservés</i> <br> Ainsi, on ne nommera pas de base de données <i>DATABASE</i> ou encore <i>CREATE</i></p><p> Concluez la création de votre base de donnée en utilisant la touche <kbd>F5</kbd> ou en utilisant le bouton d&#39;exécusion de requête représenté par un petit triangle et situé juste au dessus du query tool. </p><p> Faites un clique droit sur &#39;objet <strong>database</strong> de <strong>l&#39;explorateur d&#39;objet</strong> et sélectionnez l&#39;option <strong>refresh</strong> pour voir s&#39;affichez votre première base de données. <br> Félicitations </p><h2>Crée une table</h2><p> Pour fonctionner, votre <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> va avoir besoin de <strong>tables</strong>. </p><p> Une table est une <strong>collection de données structurées</strong>. C&#39;est à dire, un tableau dans lequel ranger vos données selon une structure définie en amont. </p><p> Dans une table, on pourra parler de <strong>colonnes</strong> qui seront nommées et définiront, entre autre, le <strong>type de donnée</strong><br> et de <strong>rangées</strong> représentant chacunes un enregistrement de données au format précisé par les colonnes. </p><p> Pour bien comprendre, nous allons créer une table dans la base de données fat_cat_clinic. Le but de cette table sera d&#39;enregistrer régulièrement les pesées de notre animal. Nous allons donc nommer cette table <i>weight</i> et réfléchir eux données nécessaires pour garder un oeil à l&#39;évolution du poids d&#39;un chat. </p><p> Un bon début sera de prendre note du poids et de la date de pesée. Nous aurons donc deux colonnes : <i>weight</i> (poids) et <i>date</i>. </p><p> En plus de définir le nom de ces colonnes, il est nécessaire d&#39;en définir le type. Pour le poids, nous utiliserons le type <strong>decimal</strong> permettant d&#39;encoder des nombres décimaux en spécifiant la précision souhaitée. Pour la date, nous utiliserons le type <strong>date</strong> permettant d&#39;encoder des... dates. </p><p> Il existe et nous utiliserons d&#39;autres types dans ce cours. Vous pouvez trouver une référence complète sur les types disponibles en suivant <a href="https://www.postgresql.org/docs/current/datatype.html"> ce lien vers la documentation officielle </a>. </p><p> Pour l&#39;instant, vous pouvez vous contentez de lire, comprendre, copier et éxecuter le code ci-dessous dans le <strong>query tool</strong> de <strong>pgAdmin</strong></p><code lang="sql"> USE fat_cat_clinic; <br> CREATE TABLE weight( <br>   weight decimal(3,1), <br>   date date <br> ); </code><p> Détaillons ensemble ce code : <br><code lang="sql">USE fat_cat_clinic;</code> permet de spécifier quelle base de données utiliser. Si vous ouvrez le <strong>query tool</strong> via la base de données ciblée, cette portion de code n&#39;est pas nécessaire. Néanmoins, n&#39;étant pas problèmatique et permettant de se prémunir d&#39;éventuelles erreurs, il sera de bon goût de l&#39;utiliser <br><code lang="sql">CREATE TABLE weight(</code> permet, vous l&#39;aurez compris, de créer une <strong>table</strong> dont le nom sera <i>weight</i> la parenthèse permet de spécifier ce que contiendra cette table <br><code lang="sql">weight decimal(3,1)</code> permet de créer, dans la table weight, une colonne weight de type décimal. Beaucoup de déclaration de type demandent des informations complémentaires. Dans le cas de decimal, il est possible de spécifier entre parenthèses la précision (le nombre de chiffres dans le nombre) et l&#39;échelle (le nombre de chiffres derrière la virgule) souhaitée. Ainsi, decimal(3,1) nous permettra d&#39;encoder des poids en kg avec une précision à l&#39;hectogramme et allant jusqu&#39;à 99,9 kg. Nous devrions être bon pour nos chats. <br><code lang="sql">date date</code> permet de comme la ligne précédente de créer une colonne. Celle-ci sera de type date <br> N&#39;oubliez pas de fermer la parenthèse et d&#39;ajouter un <kbd>;</kbd></p><h2>Ajouter des enregistrements</h2><p> Maintenant que notre <!----> weight est créée, nous allons la <span title="Du wiktionnaire : (Bases de données) Alimenter (une table, une base de données) en informations."> populer </span> avec quelques informations. </p><p> Comme pour le point précédent, lisez attentivement ce code et exécutez le </p><code lang="sql"> INSERT INTO weight (weight, date) <br>   VALUES (3.5, &#39;2024-01-19&#39;); </code><p><code lang="sql">INSERT INTO weight</code> permet d&#39;insérer des données dans la table weight </p><p> Les informations entre parenthèses <code lang="sql">(weight, date)</code> permettent de spécifier quelles valeurs seront insérées et dans quel ordre. <br> Cette information pourrait être omise tant que les valeurs insérées sont écrites dans l&#39;ordre des colonnes de la table ciblée. <br> Néanmoins, inclure cette information permet, entre autres, d&#39;éviter d&#39;éventuelles erreurs. Je vous invite donc à ajouter systématiquement cette information. </p><p> Le mot clé <code lang="sql">VALUES</code> précède les données à insérer qui sont reprises entre parenthèses <code lang="sql"> (3.5, &#39;2024-01-19&#39;) </code>. Notez que la date est entourées de <kbd>&#39;</kbd> et au format <i title="years-month-day respectivement sur 4, 2 et 2 chiffres"> yyyy-MM-dd </i></p><p> Pour bien faire, nous allons ajouter quelques données supplémentaires avec le code suivant : </p><code> INSERT INTO weight (weight, date) <br>    VALUES (3.6, &#39;2024-08-03&#39;)<br>     ,(3.7, &#39;2024-07-06&#39;) <br>     ,(3.5, &#39;2024-06-01&#39;) <br>     ,(3.6, &#39;2024-05-04&#39;) <br>     ,(3.4, &#39;2024-04-06&#39;) <br>     ,(3.4, &#39;2024-03-02&#39;) <br>     ,(3.5, &#39;2024-02-03&#39;); </code><p>Ici, la même commande est utilisée pour insérer une série de données.</p><h2>Lire les enregistrements</h2><p> Maintenant que nous avons créé une base de données, créé une table et inséré une série de données, nous pouvons commencer à lire celles-ci. Nous allons donc en profiter pour faire quelques requêtes. </p><p> La première, ci-dessous, va nous permettre de lire les informations contenues dans la table </p><code lang="sql"> SELECT weight, date FROM weight; </code><p> Les deux mots clés à retenir ici sont <code lang="sql">SELECT</code> et <code lang="sql">FROM</code>. <br><code lang="sql">SELECT</code> sera suivi des colonnes à récupérer. Vous pourriez donc ne sélectionner que les poids avec une requête <code lang="sql">SELECT weight FROM weight;</code> <br><code lang="sql">FROM</code> permet de spécifier la table dans laquelle récupérer les données. </p><p>Une seconde version de cette requête sera la suivante</p><code lang="sql">SELECT * FROM weight;</code><p> Ici, le symbole <kbd>*</kbd> sera utilisé comme <i>joker</i> pour signifier <i>toutes les colonnes</i>. <br> Pratique pour les tests, mais à ne pas utiliser de manière systématique dans vos projets de développement. Nous en reparlerons plus tard. </p><p> Pour voir l&#39;évolution dans le temps du poids du chat observé, il serait intéressant de trier les résultats par date. <br> Bonne nouvelle, c&#39;est possible avec la paire de mots clés <code lang="sql">ORDER BY</code>. </p><code lang="sql"> SELECT * FROM weight <br> ORDER BY date; </code><p> Il sera même possible de choisir l&#39;ordre du tri en ajoutant soit <code lang="sql">ASC</code> ou <code lang="sql">DESC</code> après notre <code lang="sql">ORDER BY</code></p><code lang="sql"> SELECT * FROM weight <br> ORDER BY date DESC; </code><p> Pratique ! Et cela ne s&#39;applique pas qu&#39;aux dates ! Même si dans notre cas, trier par poids semble moins pertinent, je vous invite à essayer. </p><h2>Conclusion</h2><p> Dans cette section, vous avez eu appris à créer une base de données, créer une table, insérer des enregistrements et enfin, lire des enregistrements. </p><p> Vous avez appris comment définir les types des données lors de la création de tables et aussi comment modifier une requête de lecture . </p><p> Ces différents concepts seront approfondis dans les prochaines sections </p></section><hr><section><h1>Relations</h1><ol><li>Introduction</li><li>Fonctions</li><li>ALTER et UPDATE</li><li>WHERE</li><li>Clé primaire</li><li>Clé étrangères et relations</li><li>WHERE suite</li><li>Conclusion</li></ol><hr><h2>Introduction</h2><h2>Fonctions</h2><p> Le simple fait de récupérer des données rend déjà les <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> très puissantes. Mais elles peuvent faire plus que ça. Entre autres, elles peuvent déjà traiter la donnée </p><p> Dans notre cas, nous allons essayer de récupérer le poids maximal de notre chat dans la table weight de la <abbr class="db-tooltip" title="DataBase =&gt; Base de données">DB</abbr> fat_cat_clinic. <br> Pour ce faire, nous allons utiliser une <strong>fonction</strong>. </p><p> Vous avez certainement déjà entendu parler de <strong>fonctions</strong> dans votre cours de programmation. Si ce n&#39;est le cas, voyez ça pour l&#39;instant comme des moyens d&#39;obtenir de nouvelles fonctionnalités. Le concept sera détaillé dans le cours adéquat. </p><p> Une fonction s&#39;utilise en l&#39;appelant par son nom et en spécifiant entre parenthèses, des <strong>arguments</strong>. </p><p> Selon la fonction, les arguments disposent de rôles différents. Ici, nous allons utiliser la fonction <code lang="sql">MAX(argument)</code> <br> Cette fonction est une <strong>fonction d&#39;aggrégation</strong> et permet de retourner le &quot;maximum&quot; pour les données d&#39;une colonnes spécifiées en argument </p><p>Essayez le code suivant</p><code lang="sql"> SELECT MAX(weight) FROM weight; </code><p> Vous devriez obtenir le poids maximum de notre chat. <br> Notez que la colonne retournée ne dispose pas d&#39;un nom très explicite. <br> Vous pouvez la renommer avec un <strong>alias</strong> grâce au mot clé <code lang="sql">AS</code>. Essayez donc ceci : </p><code lang="sql"> SELECT MAX(weight) AS max_weight FROM weight</code><p>C&#39;est tout de même plus clair !</p><p> En vrac, voici quelques autres fonctions d&#39;aggrégation : MIN, MAX, <abbr title="Average =&gt; moyenne">AVG</abbr>, <abbr title="Somme">SUM</abbr>, COUNT. <br> Une liste plus complète est disponible <a href="https://www.postgresql.org/docs/16/functions-aggregate.html"> ici </a></p><p> Essayez donc d&#39;afficher le poids moyen de notre chat avant de passer au prochain point. Quelque chose devrait vous gêner dans l&#39;affichage des résultats et je vous conseille vivement d&#39;aller voir le lien cité plus haut pour résoudre ce problème </p><h2>Alter</h2><p> Pour l&#39;instant, tout fonctionne comme prévu. Mais nous allons rapidement changer ça en ajoutant quelques enregistrement de poids pour un autre chat dans notre base de données. <br> Pas de problèmes. Vous savez déjà comment faire ! Un petit coup d&#39;<code lang="sql">INSERT</code> et le tour est joué... <br> Sauf qu&#39;il s&#39;agit d&#39;un maine coon pouvant atteindre jusqu&#39;à 8kg en temps normal. <br> D&#39;un seul coup plus moyen de distinguer un enregistrement très inquiétant en rapport avec le poids de votre chat d&#39;un enregistrement tout à fait normal pour un maine coon... </p><p> Si nous avions pensé à ce problème avant de créer notre table, nous aurions certainement ajouté une colonne permettant de distinguer de quel chat il s&#39;agit. Par exemple <i>name</i> ou <i>cat</i><br> Heureusement pour nous, pas besoin de supprimer notre table et toutes les données enregistrées pour recréer une table avec cette colonne supplémentaire <br> Effectivement, il est possible de modifier la définition d&#39;une table grâce à la commande <code lang="sql">ALTER</code>. <br> Essayez donc ce code : </p><code lang="sql"> ALTER TABLE weight <br>   ADD cat varchar(32); </code><p> Ce code permet <i>d&#39;altérer</i> la table weight pour y ajouter une colonne nommée <i>car</i> de type <strong>varchar</strong></p><p> Le type <strong>varchar</strong> permet de stocker du texte d&#39;un nombre de caractères allant jusqu&#39;au nombre précisé lors de la définition de la colonne. Plus d&#39;info via <a href="https://www.postgresql.org/docs/current/datatype-character.html"> ce lien </a></p><p> Sélectionnez toutes les informations de la table weight pour vérifier que cela ai bien fonctionné... Et voyez un résultat surprenant... <br> La colonne <i>cat</i> est remplie de l&#39;information <strong>[null]</strong>. <br> Rassurez vous, c&#39;est normal ! <i>null</i> signifie simplement qu&#39;il n&#39;y a pas de données. <br> Nous n&#39;avons effectivement jamais renseigné de nom pour nos enregistrements de poids jusqu&#39;à présent vu que la colonne n&#39;existait pas. </p><p>Corrigeons ce problème avec le bout de code suivant :</p><code lang="sql"> UPDATE weight <br> SET cat = &#39;Monza&#39;; </code><p> Pour ceux qui ont fait un peu d&#39;anglais, vous comprendrez vite que le mot clé <code lang="sql">UPDATE</code> permet de <strong>modifier</strong> les valeurs contenues dans une table. <br> Le mot clé <code lang="sql">SET</code> permet de spécifier la colonne ainsi que la valeur à attribuer à celle-ci. <br> Notez encore la mention <i>Monza</i> écrite entre des <kbd>&#39;</kbd>. <br> Il s&#39;agit du nom de mon chat et est écrit entre apostrophes car il s&#39;agit d&#39;une <span class="tooltip" title="chaine de caractère">string</span>. <br> D&#39;une manière générale, vous croiserez souvent les textes entourés par des <kbd>&#39;</kbd> ou bien <kbd>&quot;</kbd></p><p> Sélectionnez à nouveau les informations de la table <i>weight</i> pour voir que chaque enregistrement est maintenant au nom de <i>Monza</i></p></section><hr><section><h2>Contraintes</h2><p> Quand nous avions ajouté le nom de l&#39;animal à notre table, nous avions eu un problème de <i>null</i>. <br> Petit rappel, null représente, pour un colonne d&#39;un record, qu&#39;il n&#39;y a pas de données </p><p> Ceci nous avais contraint à modifier nos données via une requête <i>UPDATE</i> avec l&#39;utilisation d&#39;un <i>WHERE</i> et, heureusement, la différence de poids entre mon chat et celui de ma belle soeur était telle qu&#39;une clause where sur le poids de nos animaux avait suffit à discerner nos animaux </p><p> Néanmoins, à l&#39;avenir, avec plus de chats ou de pesées, ça pourrait ne plus suffire. </p><p> Nous allons donc nous prémunire de ce problème avec une <strong>constraint</strong></p><p> Une <i>constraint</i> est, comme son nom l&#39;indique, une contrainte que l&#39;on peut appliquer, par exemple, sur notre colonne <i>cat</i> pour interdire les valeurs nulles. Appliquons la avec le code suivant : </p><code> ALTER TABLE weight ALTER COLUMN cat SET NO NULL; </code><p> Pas de surprise ici. Les différents mot-clés sont presque tous connus <br> Nous <i>alterons</i> la <i>table</i> <i>weight</i> pour laquelle nous <i>alterons</i> la <i>colonne</i> <i>cat</i> <br> Pour cette colonne, nous spécifions qu&#39;elle ne peut pas contenir la valeur <i>null</i> avec <strong>SET NO NULL</strong></p><p> Tant que nous y somme, posons nous la question : est-ce qu&#39;une pesée sans poids peut avoir du sens? quid d&#39;une pesée non datée? Ajoutons aussi les contraintes <i>NO NULL</i> pour ces deux colonnes </p><p> Vous avez peut-être essayé de mettre la contrainte <i>NO NULL</i> alors que votre colonne contenait déjà des valeurs nulles. <br> Non? <br> Essayez-donc pour voir le résultat <br> Essayez aussi d&#39;insérer des valeurs nulles maintenant que les contraintes sont appliquées </p><h2>Problème de poids</h2><p> Pour profiter des capacités de notre base de données à traiter la donnée lors de la récupération, nous allons ajouter quelques informations de <strong>référence</strong> dans notre table. </p><p>En vrac :</p><ul><li>Le poids moyen vers lequel devrait tendre notre chat</li><li>La race de notre chat</li><li>Son sexe</li><li>Son âge</li><li>S&#39;il est stérilisé</li></ul><p> Si nous ajoutons toutes ces informations notre table weight, nous nous retrouvons avec ce genre de résultat </p><table><thead><tr><th>weight</th><th>date</th><th>cat</th><th>ideal_weight</th><th>race</th><th>is_male</th><th>age</th><th>neutered</th></tr></thead><tbody><tr><td>3.5</td><td>&#39;2024-02-02&#39;</td><td>&#39;Monza&#39;</td><td>6.5</td><td>&#39;Persan&#39;</td><td>true</td><td>7</td><td>true</td></tr><tr><td>3.6</td><td>&#39;2024-03-04&#39;</td><td>&#39;Monza&#39;</td><td>6.5</td><td>&#39;Persan&#39;</td><td>true</td><td>7</td><td>true</td></tr><tr><td>3.5</td><td>&#39;2024-04-02&#39;</td><td>&#39;Monza&#39;</td><td>6.5</td><td>&#39;Persan&#39;</td><td>true</td><td>7</td><td>true</td></tr><tr><td>3.6</td><td>&#39;2024-05-10&#39;</td><td>&#39;Monza&#39;</td><td>6.5</td><td>&#39;Persan&#39;</td><td>true</td><td>7</td><td>true</td></tr><tr><td>3.7</td><td>&#39;2024-06-08&#39;</td><td>&#39;Monza&#39;</td><td>6.5</td><td>&#39;Persan&#39;</td><td>true</td><td>7</td><td>true</td></tr></tbody></table><p> prennez un peu de temps pour regarder ces données et remarquons quelque chose... </p><p> Nous avons beaucoup de <strong>répétitions</strong> et cela est un problème. </p><p> Tout d&#39;abord, nous devons maintenant ajouter ces informations lors de l&#39;insertion de chaque record dans notre table <i>weight</i>. <br> Non seulement, cela va nous prendre plus de temps, mais en plus, c&#39;est une source d&#39;erreur potentielle ! <br> Que faire quand mon chat sera une fois de race <i>persan</i> et une autre de race <i>maine coon</i> ? Quelle information conserver ? </p><p> Ensuite, nous augmentons considérablement le poids de chaque record pour des informations qui ne sont pas variables entre deux pesées (sauf pour l&#39;âge et s&#39;il est stérilisé. Nous reviendrons là-dessus plus tards) <br> Effectivement, nous passons d&#39;un record avec 3 champs assez léger à un record de 8 champs ! <br> Et bien que ceux-ci ne soient pas individuellement trop lourd, le poids de ceux-ci se fera sentir lors de l&#39;accumulation d&#39;un plus grand nombre de records. </p><p> Réflechissez a de potentielles solutions à ce problème de répétition de données avant de lire la suite. <br> Comment pourriez-vous résoudre ce problème si vous preniez des notes papier plutôt qu&#39;en utilisant une base de données? </p><h2>Relations</h2><p> Je vous propose de résoudre ce problème en vous présentant le principe de relations dans une base de données </p><p> Certains l&#39;auront déjà remarqué ou entendu : on parle parfois de base de données <strong> relationnelles </strong>. <br> L&#39;idée est simple : créer plusieurs tables et établir des <i>relations</i> entre ces tables pour pouvoir liers les données de l&#39;une et de l&#39;autre </p><p> Dans notre cas, nous pourrions séparer nos données entre celles qui sont en rapport direct avec notre chat en soi (nom, race, sexe, age, poids idéal, stérilisé ) et celles qui ont un rapport avec les différentes pesées de nos chats (poids, date et nom) <br> Nous aurions donc les deux tables suivantes : </p><p>weight</p><ul><li>weight</li><li>date</li><li>name</li></ul><p>cat</p><ul><li>name</li><li>race</li><li>is_male</li><li>age</li><li>ideal_weight</li><li>neutered</li></ul><p> Vous avez remarqué quelque chose? <br> C&#39;est ça, la colonne <i>name</i> est dupliquée dans les deux tables car une pesée est liée à un chat, tout comme les informations générales ! <br> C&#39;est normal gardez bien ça en tête car nous allons en profiter par après. <br> En attendant, mettons en place ces deux tables avec le code suivant : </p><pre>      CREATE TABLE weighting(
        name varchar(32),
        date date,
        weight numeric(3,1)
      );

      CREATE TABLE cat(
        name varchar(32),
        race varchar(32),
        is_male boolean,
        age int,
        ideal_weight numeric(3,1),
        neutered boolean
      )
    </pre><p>Et ajoutons quelques données</p><pre>      INSERT INTO weighting (weight, date, name) 
      VALUES (3.6, &#39;2024-08-03&#39;, &#39;Monza&#39;)
        ,(3.7, &#39;2024-07-06&#39;, &#39;Monza&#39;) 
        ,(3.5, &#39;2024-06-01&#39;, &#39;Monza&#39;) 
        ,(3.6, &#39;2024-05-04&#39;, &#39;Monza&#39;) 
        ,(3.4, &#39;2024-04-06&#39;, &#39;Monza&#39;) 
        ,(3.4, &#39;2024-03-02&#39;, &#39;Monza&#39;) 
        ,(3.5, &#39;2024-02-03&#39;, &#39;Monza&#39;)
        ,(7.5, &#39;2024-06-03&#39;, &#39;Plume&#39;) 
        ,(7.6, &#39;2024-05-04&#39;, &#39;Plume&#39;) 
        ,(7.5, &#39;2024-04-05&#39;, &#39;Plume&#39;) 
        ,(7.4, &#39;2024-03-02&#39;, &#39;Plume&#39;);
      
      INSERT INTO cat (name, race, is_male, age, ideal_weight, neutered)
      VALUES (&#39;Monza&#39;, &#39;Persan&#39;, true, 7, 6.5, true)
        ,(&#39;Plume&#39;, &#39;Maine coon&#39;, false, 5, 6, true)
    </pre><p> Vous devriez être en mesure d&#39;identifier tout les éléments de ces deux requêtes, bien que certains types soient utilisés ici pour la première fois. <br> Si des questions persistaient, n&#39;hésitez pas à consulter les chapitres précédents ou à faire une recherche rapide sur internet avant de passer à la prochaine section </p><h2>Jointures (introduction)</h2><p> Revenons maintenant à cette donnée dupliquée <br> Vous vous souvenez, nous avions parlé plus tôt de relations entre les tables... <br> Et bien c&#39;est cette donnée dupliquée qui va nous permettre de créer et manipuler ces relations. <br> Nous pouvons maintenant mettre <i>en relation</i> les données <i>name</i> des tables <i>weighting</i> et <i>cat</i> (il ne s&#39;agit pas ici de la véritable définition d&#39;une relation en base de données. Nous reviendrons sur celle-ci plus tard) <br></p><p> Maintenant, si nous voulons récupérer une pesée ainsi que le poids idéal de notre chat, nous n&#39;avons &quot;qu&#39;à&quot; récupérer les données présentes dans la table <i>weighting</i> pour &#39;Monza&#39;... Et, toujours pour &#39;Monza&#39;, les données de la table <i>cat</i>... En même temps... <br> Pas de panique, c&#39;est nettement moins compliqué que ça en à l&#39;air. Analysez plutôt le code ci-dessous : </p><pre>      SELECT cat.name, cat.ideal_weight, weighting.weight, weighting.date
      FROM cat
      JOIN weighting ON cat.name = weighting.name
      ORDER BY weighting.date DESC;
    </pre><p> Tout d&#39;abord, notons une différence sur l&#39;écriture des noms de colonne. <br> Elles sont nommées avec le nom de la table, suivie d&#39;un point et du nom de colonne. <br> Ceci permet, lors de la manipulation de plusieurs tables, de ne pas se tromper sur la provenance des données. <br> Cette nomenclature était d&#39;ailleurs déjà faisable avec une unique table, mais a tendance à rendre plus lourde la lecture et a donc été évitée. <br> À l&#39;inverse, la nomenclature sans le nom de table est tout à fait envisageable pour les colonnes comme ideal_weight pour lesquelles la provenance ne fait aucun doute. Mais il est en général avisé de précéder chaque colonne de sa table lors de jointures pour se faciliter la tâche à la lecture. </p><p> Ensuite, regardons le nouveau mot clé en deux partie <br><code>JOIN table ON critère</code> permet de <i>joindre</i> une table à la table courante sur base d&#39;un critère. De faire une <strong>liaison</strong>, une <strong>jointure</strong>. Ici, le critère est une simple égalité entre les valeurs des colonnes <i>name</i> des tables <i>cat</i> et <i>weighting</i></p><p> Pour le plaisir de la lecture, réduisont un peu la taille de cette requête en utilisant une notion vue précédement, les alias, mais sur les tables. </p><pre>      SELECT c.name, c.ideal_weight, w.weight, w.date 
      FROM cat AS c 
      JOIN weighting as w on c.name = w.name
      ORDER BY w.date DESC;
    </pre><p> Encore mieux, nous prenoms toutes les colonnes de la table <i>weighting</i>. Essayons ceci : </p><pre>      SELECT w.*, c.ideal_weight 
      FROM cat as c 
      JOIN weighting as w on c.name = w.name 
      ORDER BY w.date DESC;
    </pre><p> Il est même possible de faire une requête de ce genre <code>SELECT w.*, c.*</code>. Je vous laisse imaginer le résultat </p><p>Avant de passez à la section suivante, je vous propose deux exercices</p><p> D&#39;abord, essayez de modifier encore la base de données en séparant les données dans une troisième table. <br> Réfléchissez bien à la manière de séparer les données de façon logique, et, si vous avez besoin d&#39;un indice, demandez-vous ce qu&#39;il se passerait si nous ajoutions un autre chat persan ou maine coon </p><p> Ensuite, maintenant cette séparation faite, essayez de récupérer les informations en faisant une double jointure ! (si, si, c&#39;est faisable) <br> Vous devrez certainement faire une recherche internet pour trouver une solution. Mais n&#39;hésitez pas à tester ce qu&#39;il vous semblerait logique avant ça. Quitte à vous tromper. </p></section><hr><section><h1>Liste de liens et références externes</h1><table><thead><tr><th>Site web</th><th>Page</th><th>Vu dans</th><th>Lien</th><th>Commentaire</th></tr></thead><tbody><tr><td>Site officiel postgresql</td><td>Page de téléchargement</td><td>Préambule</td><td>https://www.postgresql.org/download/</td><td></td></tr><tr><td>Documentation officielle postgresql</td><td>Data type</td><td>Première DB</td><td>https://www.postgresql.org/docs/current/datatype.html</td><td></td></tr><tr><td>Documentation officielle postgresql</td><td>Fonctions d&#39;aggrégation</td><td>Relations</td><td>https://www.postgresql.org/docs/16/functions-aggregate.html</td><td></td></tr><tr><td>Documentation officielle postgresql</td><td>Types de données de texte</td><td>Relations</td><td> https://www.postgresql.org/docs/current/datatype-character.html </td><td></td></tr></tbody></table></section><hr></main><!--]--></div></div><div id="teleports"></div><script type="application/json" id="__NUXT_DATA__" data-ssr="true" data-src="/_payload.json?6dfd114d-e386-4ca1-81b4-a7bcd2d9e858">[{"state":1,"once":3,"_errors":5,"serverRendered":7,"path":8,"prerenderedAt":9},["Reactive",2],{},["Reactive",4],["Set"],["Reactive",6],{},true,"/",1726227104484]</script>
<script>window.__NUXT__={};window.__NUXT__.config={public:{},app:{baseURL:"/",buildAssetsDir:"/_nuxt/",cdnURL:""}}</script></body></html>